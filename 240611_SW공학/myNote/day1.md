# day1


## 1장. SW 공학 소개

### SW의 특징
* best practice (실전 -> 이론)
* SW 개발 전반에 필요한 이론
* 실리콘밸리에서의 이론들 적용
* SW공학 이론을 모두 적용해야 하는가?
    * 창의성 or 품질?
    * 어디에 초점을 맞추는지에 따라 팀의 구조도 변경됨
    * SW공학은 경험에서 나온 이론이므로 꼭 그대로 따라할 필요는 없다(성공이 보장되지 않음)
    * SW의 용도에 따라(유지보수 등) 아키텍처가 필요하지 않은 경우도 있음
* 자동차 산업에서 SW공학을 적용하는 이유
    * 크기가 커짐
    * 복잡도가 높아짐
    * 크리티컬 도메인(생명, 국방 등)의 품질 보장
* SW의 특징
    * 복잡성
    * 순응성(호환, 유연)
    * 유형성 : 프로그램과 관련된 문서들의 집합
    * 비제조성
    * 비조립성
    * 견고성
    * 비마모성 : 사용자 요구에 의한 품질 저하

### SW의 위기
* 60-70년대 발생한 다양한 문제
    * 요구사항 증가
    * 복잡성과 규모 증가
    * 개발비용 초과, 개발일정 부족
    * 성능, 품질 저하
    * 유지보수의 비용증가
* 소프트웨어 개발의 특성
    - 인간의 지적 노동력 집약적인 생산
* 핵심적인 문제점
    * 개발예산, 개발일정
    * 생산성
    * 품질
    * (+) 사용자의 만족도(수요)
* 원인
    * 특성 이해 부족
    * 관리 부재(프로그래밍에만 치중)
    * 개발 전문인력 부족(전반적 지식없이 단순 코딩)
    * 복잡도 증가
    * 개발비용 증가
* 최근 소프트웨어 개발 동향
    * 고객의 요구사항을 유연하게 반영하기 위해 끊어서 개발(버퍼 유지)
    * 시장적기에 맞게 빠르게 출시
    * 부족한 부분은 업데이트

### 관리자의 잘못된 의식구조
* 문서가 자세하면 개발이 쉽다?
* 개발도구만 지원하면?
* 인력 추가 투입만으로 개발일정을 맞춘다?
    - brooks law : 추가된 인력으로 지연시간이 발생 
* 교육만으로 우수한 개발자 확보?

### 사용자의 잘못된 의식구조
* 시스템과 개발목표만으로 프로그래밍 착수?
* 상세내역은 즉시 프로그램에 추가?
* 프로그램 개발 도중 요구를 쉽게 반영한다?

### 개발자의 잘못된 의식구조
* 완성과 테스트가 끝나면 개발 끝? -> 유지보수
* 개발 완료시 남는건 프로그램뿐이다?
* 결과물 검토회는 불필요?
* 유지보수는 간단하다?
* 문서화는 시간낭비?

### 소프트웨어 공학 정의
* SW 개발과정에서 과학적 지식을 체계적으로 적용하는학문 분야,개발과 운영,유지보수, 소멸에 대한 체계적인 접근 방법

### 소프트웨어 공학 목표
* 생산성, 품질 향상
    * 좋은 품질이란
    - 올바른 작동
    - 요구사항 만족정도
    - 유지보수 용이함
* 복잡도 낮춤
* 비용 절감
* 개발기간 단축
* 대규모 프로젝트 관리
* 고품질
* 효율성

### 소프트웨어 공학 3가지 주제
* 프로세스
* 품질보증
* 프로젝트관리

### 프로세스 주요 활동
* (계획)
    - 시스템 정의
    - 가능성 분석
    - 일정수립
* 요구분석
* 설계
* 구현
* 테스팅
    * 문제를 고치는 단계가 아니라 완성 단계
    * 이 전 단계에서 문제를 모두 수정해야함
* (유지보수)

### 품질보증
* verification + validation
* 품질 좌우 요소 : 모든 요소를 동시에 확보해야 함
    * 인력
    * 프로세스
    * 기술

### 프로젝트 관리
* 프로젝트 계획
* 자원 관리
* 리스크 관리
* 프로젝트 수행 및 모니터링

### SW공학의 다양한 관점
* 계획관점
    * 개발 전 과정에 거쳐서 반복 수행 해야함
* 분석/설계 관점
    * 유지보수 절감을 위해 개발 초기 단계에서 결함을 발견
* 테스트 관점
    * 전과정에 거친 테스트로 불필요한 비용 절감
* 문서 관점
    * 결과물을 문서로 작성하는 것이 필요
    * 문서화가 안되면 유지보수와 검사활동은 불가능
    * 전과정에 거쳐서 수행
* 유지보수 관점
    * 개발 이후 뿐 아니라 개발 과정 모든 변경(요구사항 변경)에 대한 유지보수
    * 70-80% 의 유비보수 비용 발생
    * 주된 관심사는 이 유지보수 비용을 줄이기 위한 노력

### SW 공학의 연구 결과
* 방법 : 소프트웨어 제작에 사용되는 기법 절차
* 도구 : tool
* 프로세스 : 도구와 기법을 사용하여 작업하는 순서
* 패러다임 : 접근 법, 스타일

### 연관 분야 
* 컴퓨터 공학의 원리나 기술과 관련된 원리
* 이를 적용하여 문제 해결을 위한 응용 도메인

### 컴퓨터 과학과 소프트웨어 공학
* 소프트웨어는 문제를 푸는 방법 중 하나일 뿐
* 체계적으로 접근하여 문제 해결


## 2장. 프로세스와 방법론

### 소프트웨어 생명주기
* SDLC(software development life cycle)
* 요구분석 -> 설계 -> 구현 -> 테스팅 -> 유지보수 -> 폐기

### 프로세스와 방법론
* 프로세스
    * 무엇을 하는가에 중점
    * 단계적인 작업의 틀을 정의
* 방법론
    * 어떻게 하는가에 중점
    * 프로세스의 구체적인 구현

### 프로젝트, 명세, 모델
* 소프트웨어 프로젝트
    - 조직화한 프로세스를 이용해 작업 수행
* 프로세스 명세
    - 수행해야 할 작업과 수행 순서 정의
    - 가이드라인처럼 자세하지는 않음
* 프로세스 모델
    - 일반적인 프로세스를 기술한 것
    - 작업의 단계와 순서
    - 각 단계 작업의 제약이나 조건을 모아둔 것

### 프로세스
* 어떤 일을 하기 위한 특별한 방법으로 단계나 작업으로 구성

### 프로세스 종류
* 개발 프로세스 : 개발 단계에서 따르는 프로세스
* 관리 프로세스 :  개발 프로세스 외 프로세스(개발 인력 관리, 배치 등)
* 기타
    * 형상 관리 프로세스
    * 프로세스 관리 프로세스

### 소프트웨어 개발 프로세스
* 계획(why)
    * 자원(시간, 비용, 사람)
    * 범위 정하기
        - 산정
        - 리스크
        - 일정
        - 관리 전략
* 요구분석(what)
    * 요구 : 시스템이 가져야 할 능력과 조건(capability, condition)
    * 응용분야(도메인)에 집중
    * SRS(요구분석서)
* 설계(how)
    * 솔루션에 집중
    * SDD/SDS(설계명세서)
* 구현(Do it)
    * 코딩과 단위테스트
    * 설계 또는 통합 단계와 겹치기도 함
    * 이슈
        - last minute change
        - Communication over head(소통 문제)
        - 하청관리
* 통합과 테스트
    * 병행 : 통합해 나가면서 테스트 시작
    * 모듈의 통합으로 시작
    * 단계적인 테스트 : 단위 -> 통합 -> 시스템
    * 목적 중심 테스트

* 설치와 유지보수
    * 설치는 개발 프로젝트의 일부 유지보수는 별개
    * 유지보수
        - 결함 해결
        - 기능 추가
        - 성능 향상
### 좋은 프로세스의 특성
* 예측 가능성
* 테스트와 유지보수 용이
* 변경 지원
* 결함 제거

### 프로세스 모델
* 일반적인 모델이 될만한 프로세스
* 대표적인 프로세스 모델
    - 폭포수 모델
    - 프로토타이핑 모델
    - 나선형 모델
    - 애자일 프로세스

### 폭포수(waterfall) 모델
* 각 단계가 다음단계 시작 전에 끝나야 함
    - 순서적
    - 바로 전단계로 피드백
* 단순하거나 응용 분야를 잘 알고 있는 경우 적합
    - 한번의 과정, 비전문가가 사용할 시스템 개발에 적합
    - 국방과 같이 개발 순서와 목표가 명확한 경우 사용되기도 함
    - 변화가 적은 프로젝트에 적합
* 결과물 정의가 중요함
* 장점
    - 단순한 프로세스, 초보자 적용 가능
    - 중간 산출물이 명확함, 관리 용이
    - 코드 생성전 충분한 연구와 분석단계
* 단점
    - 소용없는 다종의 문서를 생산할 가능성
    - 프로젝트 진행 과정에 변경을 수용하기 쉽지 않다
    - 테스트 작업이 후반(시스템 완성 후)에 이루어짐

### V 모델
* 검증을 강화하는 관점에서 폭포수 모델을 확장한 모델
* 신뢰성이 높이 요구되는 분야
* 감추어진 반복과 재작업을 들어낸 모델
* 작업과 결과 검증에 초점
* 장점
    - 오류를 줄일 수 있음
* 단점
    - 반복이 없어 변경을 다루기 쉽지 않음

### 프로토타이핑 모델
* 요구사항에 대한 피드백을 받기 위해 시스템을 실험적으로 만들어 사용자에게 보여주고 평가하게 하는 방법
* 장점
    - 사용자의견 반영이 잘 됨
    - 사용자가 더 관심을 갖고 참여할 수 있고, 개발자는 요구를 더 정확히 도출
* 단점
    - 오해, 기대심리 유발
    - 관리가 어려움(중간 산출물 정의가 난해)

### 진화적 모델
* 개발사이클이 짧은 환경
    - 빠른 시간 안에 시장에 출시하여야 이윤에 직결
    - 개발시간 줄이는 법(시스템을 나누어 릴리즈)
* 릴리스 구성 방법
    - 점증적 방법 : 기능별로 릴리즈
    - 반복적 방법 : 릴리즈 때마다 기능의 완성도를 높임
* 장점
    - 몇가지 기능이 부족하더라도 초기에 사용 교육 가능
    - 요구사항 빠르게 반영
    - 새로운 기능을 가진 소프트웨어에 대한 시장을 빠르게 형성
* 단점
    - 프로젝트 관리가 복잡해지기 때문에 작은 프로젝트 부적합
    - 끝이 안보일 수 있어 실패의 위험이 커짐(요구사항이 계속 들어 올 수 있음)
    - 프로젝트의 진행이 위험 분석에 크게 의존

### 나선형 모델
* 소프트웨어의 기능을 나누어 점증적으로 개발
    - 실패의 위험을 줄임
    - 테스트 용이
    - 피드백
* 여러 번의 점증적인 릴리스
* Boehm이 제안
* 반복 순환 단계
    1. 목표, 방법, 제약 조건 결정
    2. 위험 요소 분석 및 해결
    3. 개발과 평가
    4. 다음 단계의 계획
* 장점
    - 대규모 시스템 개발에 적합
    - 반복적인 개발 및 테스트
    - 한 사이클에 추가 못한 기능은 다음 단계에 추가
* 단점
    - 관리가 복잡
    - 위험 분석을 잘못하여 지나친 경우 피해가 큼
    - 성공 사례가 많이 알려지지 않음(현업에 정착이 힘듦)
* 적용
    - 재정적또는 기술적으로 우험 부담이 큰 경우
    - 요구 사항이나 아키텍처 이해에 어려운 경우

### 애자일 프로세스
* 폭포수 프로세스의 단점을 해결
* 절차와 도구보다는 개인과 소통을 중요시 함
* 애자일 선언
    - 공정과 도구보다 개인과 상호작용을
    - 포괄적인 문서보다 작동하는 소프트웨어를
    - 계약 협상보다 고객과의 협력을
    - 계획을 따르기보다 변화에 대응하기를
* 애자일 철학이 반영된 프로세스
    * 스크럼 : 짧은주기(스프린트)로 이루어짐
        - 스프린트 계획
        - 백로그
        - 일일미팅
        - the war room
        - burndown chart
        - 스프린트 리뷰/회고